/* eslint-disable */
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
/**
 * App PARAMETERS
 */
window.EC5_LIBRARIES.PARAMETERS = {

    APP_NAME: 'Epicollect5',

    //platforms
    WEB: 'WEB',
    ANDROID: 'Android',
    IOS: 'iOS',

    // url paths
    API: {
        ROUTES: {
            ROOT: '/api',
            PROJECT: '/project/',
            PROJECTS: '/projects/',
            UPLOAD: '/upload/',
            MEDIA: '/media/',
            PROJECT_VERSION: '/project-version/',
            GET_LOGIN: '/login',
            LOGIN: '/login/',
            HANDLE_GOOGLE: '/handle/google',
            GOOGLE_AUTH: 'https://accounts.google.com/o/oauth2/auth?',
            LOCALHOST: 'http://localhost',
            ENTRIES: '/entries/',
            OPENCAGE: '/api/proxies/opencage/'
        },
        PARAMS: {
            MEDIA: '?type=photo&name=logo.jpg&format=project_mobile_logo',
            GOOGLE_CODE: 'code'
        }

    },

    PHOTO_EXT: '.jpg',
    AUDIO_EXT: '.mp4',
    AUDIO_EXT_IOS: '.wav', //ios audio recording is only wav
    VIDEO_EXT: '.mp4',

    ALLOWED_ORDERING_COLUMNS: ['title', 'created_at'],
    ALLOWED_ORDERING: ['ASC', 'DESC'],

    DEFAULT_ORDERING_COLUMN: 'created_at',
    DEFAULT_ORDERING: 'DESC',

    AUTH_ERROR_CODES: [
        'ec5_70',
        'ec5_71',
        'ec5_77',
        'ec5_78',
        'ec5_50',
        'ec5_51'
    ],

    PROJECT_OUTDATED_ERROR_CODES: [
        'ec5_201'
    ],

    ENTRY_ADD: 'ADD',
    ENTRY_EDIT: 'EDIT',
    ENTRY_UPLOAD: 'UPLOAD',

    // Error codes which should stop all entry uploads, ie project does not exist, user not authenticated etc
    UPLOAD_STOPPING_ERROR_CODES: [
        'ec5_11', // project does not exist
        'ec5_50', // problem with JWT
        'ec5_51', // problem with JWT
        'ec5_70', // log in
        'ec5_71', // need permission
        'ec5_77', // private project, log in
        'ec5_78', // private project, need permission
        'ec5_116', // server error
        'ec5_201', // project version out of date
        'ec5_202' // project inactive
    ],

    ENTRY: 'entry',
    ENTRIES_TABLE: 'entries',

    BRANCH_ENTRY: 'branch_entry',
    BRANCH_ENTRIES_TABLE: 'branch_entries',

    // Jumps
    JUMPS: {
        IS: 'IS',
        IS_NOT: 'IS_NOT',
        NO_ANSWER_GIVEN: 'NO_ANSWER_GIVEN',
        ALL: 'ALL',
        END_OF_FORM: 'END'
    },

    INPUT_TYPES: {
        EC5_TEXT_TYPE: 'text',
        EC5_TEXTAREA_TYPE: 'textarea',
        EC5_INTEGER_TYPE: 'integer',
        EC5_DECIMAL_TYPE: 'decimal',
        EC5_DATE_TYPE: 'date',
        EC5_TIME_TYPE: 'time',
        EC5_RADIO_TYPE: 'radio',
        EC5_CHECKBOX_TYPE: 'checkbox',
        EC5_DROPDOWN_TYPE: 'dropdown',
        EC5_BARCODE_TYPE: 'barcode',
        EC5_LOCATION_TYPE: 'location',
        EC5_AUDIO_TYPE: 'audio',
        EC5_VIDEO_TYPE: 'video',
        EC5_PHOTO_TYPE: 'photo',
        EC5_BRANCH_TYPE: 'branch',
        EC5_GROUP_TYPE: 'group',
        EC5_README_TYPE: 'readme',
        EC5_SEARCH_SINGLE_TYPE: 'searchsingle',
        EC5_SEARCH_MULTIPLE_TYPE: 'searchmultiple',
        EC5_DATASET_SINGLE_TYPE: 'datasetsingle',
        EC5_DATASET_MULTIPLE_TYPE: 'datasetmultiple'
    },

    INPUT_ANSWER_MAX_LENGTHS: {
        EC5_TEXT_TYPE: 255,
        EC5_TEXTAREA_TYPE: 1000,
        EC5_INTEGER_TYPE: 255,
        EC5_DECIMAL_TYPE: 255,
        EC5_DATE_TYPE: 25,
        EC5_TIME_TYPE: 25,
        EC5_RADIO_TYPE: 13,
        //EC5_CHECKBOX_TYPE: '',
        EC5_DROPDOWN_TYPE: 13,
        EC5_BARCODE_TYPE: 255,
        //EC5_LOCATION_TYPE: '',
        EC5_AUDIO_TYPE: 51,
        EC5_VIDEO_TYPE: 51,
        EC5_PHOTO_TYPE: 51,
        EC5_BRANCH_TYPE: 0,
        EC5_GROUP_TYPE: 0
    },

    //date formats
    DATE_FORMAT_1: 'dd/MM/YYYY',
    DATE_FORMAT_2: 'MM/dd/YYYY',
    DATE_FORMAT_3: 'YYYY/MM/dd',
    DATE_FORMAT_4: 'MM/YYYY',
    DATE_FORMAT_5: 'dd/MM',

    //time formats
    TIME_FORMAT_1: 'HH:mm:ss',
    TIME_FORMAT_2: 'hh:mm:ss',
    TIME_FORMAT_3: 'HH:mm',
    TIME_FORMAT_4: 'hh:mm',
    TIME_FORMAT_5: 'mm:ss',

    MAX_SEARCH_HITS: 10,
    MAX_DATASET_HITS: 10,
    MAX_BRANCH_QUESTION_RENDERING_LENGHT: 50
};

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
/**
 * App STRINGS
 */
window.EC5_LIBRARIES.STRINGS = {
    en: {
        labels: {
            prev: 'Prev',
            next: 'Next',
            quit: 'Quit',
            save: 'Save',
            save_entry: 'Save entry',
            quit_entry: 'Quit',
            save_branch_entry: 'Save branch entry',
            quit_branch: 'Quit',
            login: 'Login',
            logout: 'Logout',
            scan: 'Scan',
            entries: 'entries',
            update_location: 'Update location',
            not_located_yet: 'Not set yet',
            latitude: 'Latitude',
            longitude: 'Longitude',
            accuracy: 'Accuracy',
            unknown_error: 'Unknown error',
            db_created: 'Epicollect5 database ready',
            db_not_created: 'Error creating Epicollect5 database!',
            locating: 'Locating',
            wait: 'Please Wait...',
            saving: 'Saving...',
            loading: 'Loading...',
            acquiring_position: 'Acquiring position',
            location_acquired: 'Location acquired',
            location_fail: 'Not able to locate!',
            location_service_fail: 'Location Services and Permissions must both be enabled for Epicollect5 to get the device location.',
            ios_location_permission_denied: 'Epicollect5 location permission was denied, please enable it in Settings',
            ios_location_permission_restricted: 'Epicollect5 location permission is restricted for the current user',
            android_location_permission_denied_always: 'Epicollect5 location permission is denied, please grant it. It is not possible to use Location Services without appropriate permission',
            no_projects_found: 'No projects found',
            date_selected_is: 'The date selected is: ',
            time_selected_is: 'The time selected is: ',
            preparing_scanner: 'Preparing scanner',
            failed_because: 'Failed because: ',
            stop: 'Stop',
            play: 'Play',
            record: 'Record',
            recording: 'Recording',
            playing: 'Playing',
            recording_audio: 'Recording audio...',
            playing_audio: 'Playing audio...',
            shoot: 'Shoot',
            video_saved: 'Video saved',
            cannot_save_file: 'Cannot save the file! Please retry',
            file_available: 'File available',
            uploading_entries: 'Uploading Entries',
            loading_project: 'Loading project',
            loading_entries: 'Loading entries',
            loading_entry: 'Loading entry',
            no_entries_found: 'No entries found',
            pick_possible_answer: 'Pick possible answer',
            permission_denied: 'Permission denied',
            location_not_available: 'Location is not available, Epicollect5 will not be able to locate you.',
            min: 'Min',
            max: 'Max',
            no_answer_given: 'No answer given ',
            error: 'Error',
            delete_project: 'Delete project',
            delete_entry: 'Delete entry',
            delete_all_entries: 'Delete all entries',
            delete_synced_entries: 'Delete synced entries',
            delete_unsynced_entries: 'Delete unsynced entries',
            bookmark: 'Bookmark',
            bookmark_title: 'Bookmark title',
            close: 'Close',
            add_bookmark: 'Add bookmark',
            add_entry: 'Add entry',
            type_hint: 'Type here',
            menu: 'Menu',
            project_options: 'Project Options',
            upload_entries: 'Upload Entries',
            download_entries: 'Download Entries',
            unsync_all_entries: 'Unsync all entries',
            unsync_entry: 'Unsync entry',
            bookmark_page: 'Bookmark page',
            remove_bookmark: 'Remove bookmark',
            order: 'Order',
            newest: 'Newest',
            oldest: 'Oldest',
            sign_in: 'Signing in',
            no_bookmarks_found: 'No bookmarks found',
            my_bookmarks: 'My bookmarks',
            export_entries: 'Export json entries',
            exporting: 'Exporting',
            exporting_success: 'All entries exported!',
            exported_to: 'Exported to: ',
            deleting_project: 'Deleting project',
            deleting_entries: 'Deleting entries',
            entry_deleted: 'Entry deleted',
            email: 'Email',
            password: 'Password',
            ldap_username: 'Ldap Username',
            ldap_password: 'Ldap Password',
            google_sign_in: 'Google Sign In',
            upload_data: 'Upload data',
            upload_photos: 'Upload photos',
            upload_videos: 'Upload videos',
            upload_audio: 'Upload audio',
            uploading_photos: 'Uploading photos',
            uploading_videos: 'Uploading videos',
            uploading_audio: 'Uploading audio',
            all_entries_uploaded: 'All Entries Uploaded',
            entries_errors: 'Some of the entries have errors',
            children: 'Children',
            search_for_project: 'Search for a project',
            add_project: 'Add Project',
            projects: 'Projects',
            delete_branch_entry: 'Delete Branch Entry',
            back: 'Back',
            settings: 'Settings',
            server_url: 'Server Url',
            server_url_placeholder: 'eg http://www.mydomain.com',
            downloads: 'Downloads',
            download: 'Download',
            warning: 'Warning',
            missing_permission: 'You must grant the appropriate permission to perform this action',
            please_wait: 'Please Wait...',
            server_url_error: 'Server not found, please check your server URL in the settings',
            quitting: 'Quitting',
            cancel: 'Cancel',
            project_outdated: 'Form has been updated.',
            update_project: 'Update form on your device?',
            project_updated: 'Forms updated.',
            updating_project: 'Updating Forms.',
            updating_entries: 'Updating entries.',
            check_for_updates: 'Check for Form Updates',
            checking_for_updates: 'Checking for updates...',
            loading_projects: 'Loading Projects',
            incomplete_entry: 'This entry is incomplete',
            unsynced_entries: 'You have unsynced entries.',
            unsynced_entry: 'This entry is unsynced.',
            sync_now: 'Upload now',
            save_entry_and_sync: 'Save entry and Sync',
            check_entries: 'Check entries',
            connect_to_internet_to_upload: 'Please connect to the internet to upload entries.',
            entries_errors_page: 'Entries with Errors',
            check_entries_below: 'Check the entries below for errors.',
            branch: 'Branch',
            pattern: 'Pattern',
            required: '* This field is required',
            entries_media_errors: 'Could not upload your media. Please try again later.',
            db_updated: 'Database updated.',
            downloading_entries: 'Downloading entries',
            all_entries_downloaded: 'All Entries Downloaded.',
            unsaved_branch_entries: 'There are unsaved Branch Entries.',
            save_now: 'Save Now',
            incomplete_entries: 'You have incomplete entries which cannot be uploaded.',
            load_more: 'Load More'
        }
    }
};

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.AnswerService = window.EC5_LIBRARIES.AnswerService || {};
/**
 * Answer Service - for processing question jumps
 */
(function answerService (module) {

    /**
     * Generate a default answer
     *
     * @param entry
     * @param inputRef
     */
    module.generateAnswer = function (entry, inputRef) {

        const inputsExtra = window.EC5_LIBRARIES.ProjectModel.getExtraInputs();
        const inputDetails = inputsExtra[inputRef].data;

        // Add answer
        entry.answers[inputDetails.ref] = module.createDefaultAnswer(inputDetails);

        if (inputDetails.type === window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_GROUP_TYPE) {
            // Add group answers to main group
            const group = window.EC5_LIBRARIES.ProjectModel.getFormGroups(entry.formRef);
            for (let j = 0; j < group[inputDetails.ref].length; j++) {
                const groupInputDetails = inputsExtra[group[inputDetails.ref][j]].data;
                // Add answer
                entry.answers[groupInputDetails.ref] = module.createDefaultAnswer(groupInputDetails);

            }
        }

    };

    /**
     * Create default set of answers
     *
     * @param inputDetails
     * @returns {{}}
     */
    module.createDefaultAnswer = function (inputDetails) {

        const answer = { was_jumped: false };
        let defaultAnswer;
        let i;

        switch (inputDetails.type) {

            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_CHECKBOX_TYPE:
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_SEARCH_SINGLE_TYPE:
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_SEARCH_MULTIPLE_TYPE:

                defaultAnswer = [];

                // Check if we have a 'default' answer in the input details
                if (inputDetails.default !== null) {

                    // Check that this default answer is a valid possible answer
                    for (i = 0; i < inputDetails.possible_answers.length; i++) {

                        if (inputDetails.default === inputDetails.possible_answers[i].answer_ref) {
                            defaultAnswer = [inputDetails.default];
                        }
                    }
                }

                answer.answer = defaultAnswer;

                break;

            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_DATASET_SINGLE_TYPE:
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_DATASET_MULTIPLE_TYPE:

                defaultAnswer = [];

                //// Check if we have a 'default' answer in the input details
                //if (inputDetails.default !== null) {
                //
                //    // Check that this default answer is a valid possible answer
                //    for (i = 0; i < inputDetails.possible_answers.length; i++) {
                //
                //        if (inputDetails.default === inputDetails.possible_answers[i].answer_ref) {
                //            defaultAnswer = [inputDetails.default];
                //        }
                //    }
                //}

                answer.answer = defaultAnswer;

                break;

            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_RADIO_TYPE:
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_DROPDOWN_TYPE:

                defaultAnswer = '';

                // Check if we have a 'default' answer in the input details
                if (inputDetails.default !== null) {

                    // Check that this default answer is a valid possible answer
                    for (i = 0; i < inputDetails.possible_answers.length; i++) {

                        if (inputDetails.default === inputDetails.possible_answers[i].answer_ref) {
                            defaultAnswer = inputDetails.default;
                        }
                    }
                }

                answer.answer = defaultAnswer;

                break;

            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_LOCATION_TYPE:
                answer.answer = {
                    latitude: '',
                    longitude: '',
                    accuracy: ''
                };
                break;
            default:
                // Check if we have a 'default' answer in the input details
                defaultAnswer = '';
                if (inputDetails.default !== null) {
                    defaultAnswer = inputDetails.default;
                }

                answer.answer = defaultAnswer;

        }

        return answer;
    };

    /**
     * Check for uniqueness and add to entry uniqueAnswers object
     *
     * @param entry
     * @param inputDetails
     * @param answer
     */
    module.checkUniqueness = function (entry, inputDetails, answer) {

        if (inputDetails.uniqueness !== 'none' && answer !== '') {
            // Lowercase the actual answer (if string)
            entry.uniqueAnswers[inputDetails.ref] = (typeof answer === 'string' ? answer.toLowerCase() : answer);
        }
    };

    /**
     * A final parsing of answers, to check not undefined
     * i.e. if a decimal/integer input is changed to type text, answer will be undefined
     * Also default was_jumped to false
     *
     * @param answer
     * @returns {*}
     */
    module.parseAnswer = function (answer) {

        // If we have any undefined or null answers, default to empty string
        if (answer === null || typeof answer === 'undefined' || typeof answer.answer === 'undefined' || answer.answer === null) {
            answer.answer = '';
        }

        // Default was_jumped to false, as this question was not jumped (but may previously have been)
        answer.was_jumped = false;

        return answer;
    };

    /**
     *
     * @param entry
     * @param inputs
     * @param group
     * @param inputList
     * @param parseAnswerForViewing
     * @returns {Array}
     */
    module.getAnswersTitles = function (entry, inputs, group, inputList, parseAnswerForViewing) {

        // Function for parsing answers for viewing
        if (!parseAnswerForViewing) {
            // If we're not supplied a revised function, use module function
            parseAnswerForViewing = module.parseAnswerForViewing;
        }

        const titles = [];
        let answer;
        let groupInputRef;
        let groupIndex;
        let groupInput;
        let inputRef;
        let index;
        let input;

        //parse the selected time and set the title regardless of time zone
        const _parseTimeForTitle = function (time, format) {

            let title = '';

            if (time === '') {
                return '';
            }

            //time comes like -> 2020-05-07T18:00:07.198

            const hours24 = time.substring(11, 13);
            const hours12 = ((parseInt(hours24) + 11) % 12) + 1;
            const minutes = time.substring(14, 16);
            const seconds = time.substring(17, 19);

            switch (format) {
                case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_1:
                    //HH:mm:ss (24 hrs format)
                    title = hours24 + ':' + minutes + ':' + seconds;
                    break;
                case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_2:
                    //hh:mm:ss (12 hrs format)
                    title = hours12 + ':' + minutes + ':' + seconds;
                    break;
                case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_3:
                    //HH:mm (24hrs format)
                    title = hours24 + ':' + minutes;
                    break;
                case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_4:
                    //hh:mm (12 hrs format)
                    title = hours12 + ':' + minutes;
                    break;
                case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_5:
                    //mm:ss
                    title = minutes + ':' + seconds;
                    break;
            }
            return title;
        };

        const _parseDateForTitle = function (date, format) {

            let title = '';

            if (date === '') {
                return '';
            }

            const year = date.substring(0, 4);
            const month = date.substring(5, 7);
            const day = date.substring(8, 10);

            //date comes like -> 2020-05-07T18:00:07.198

            switch (format) {
                case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_1:
                    //'dd/MM/YYYY',
                    title = day + '/' + month + '/' + year;
                    break;
                case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_2:
                    //'MM/dd/YYYY',
                    title = month + '/' + day + '/' + year;
                    break;
                case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_3:
                    title = year + '/' + month + '/' + day;
                    //'YYYY/MM/dd',
                    break;
                case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_4:
                    //'MM/YYYY',
                    title = year + '/' + day;
                    break;
                case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_5:
                    //'dd/MM',
                    title = day + '/' + month;
                    break;
            }
            return title;
        };

        var getTitles = function (input) {

            switch (input.type) {
                case 'group': {

                    // Loop group inputs
                    for (groupIndex = 0; groupIndex < group[input.ref].length; groupIndex++) {
                        groupInputRef = group[input.ref][groupIndex];
                        groupInput = inputList[groupInputRef].data;

                        // Get titles for the group
                        getTitles(groupInput);
                    }

                }
                    break;
                case 'readme':
                    // readme types have no answer
                    break;
                case window.EC5_LIBRARIES.EC5_CHECKBOX_TYPE:
                case window.EC5_LIBRARIES.EC5_SEARCH_SINGLE_TYPE:
                case window.EC5_LIBRARIES.EC5_SEARCH_MULTIPLE_TYPE:

                    // checkbox types are arrays
                    if (entry.answers[input.ref]) {
                        answer = entry.answers[input.ref].answer;

                        // If we have a title and answer not empty array
                        if (input.is_title && Array.isArray(answer) && answer.length !== 0) {
                            titles.push(parseAnswerForViewing(input, answer));
                        }
                    }
                    break;

                case 'date':
                    //create title from date regardless of timezone
                    if (entry.answers[input.ref]) {
                        answer = entry.answers[input.ref].answer;
                        // If we have a title
                        if (input.is_title && answer !== '') {
                            titles.push(_parseDateForTitle(answer, input.datetime_format));
                        }
                    }
                    break;

                case 'time':
                    //create title from time regardless of timezone

                    if (entry.answers[input.ref]) {
                        answer = entry.answers[input.ref].answer;

                        // If we have a title
                        if (input.is_title && answer !== '') {

                            titles.push(_parseTimeForTitle(answer, input.datetime_format));
                        }
                    }
                    break;
                default: {
                    // Default i.e. any other input
                    // Check we have an answer
                    if (entry.answers[input.ref]) {
                        answer = entry.answers[input.ref].answer;

                        // If we have a title
                        if (input.is_title && answer !== '') {
                            titles.push(parseAnswerForViewing(input, answer));
                        }
                    }
                }
            }

        };

        // Loop all the inputs (in order) and pull out the answers for the title
        for (index = 0; index < inputs.length; index++) {
            inputRef = inputs[index];
            input = inputList[inputRef].data;
            // Get titles
            getTitles(input);
        }

        return titles;

    };

}(window.EC5_LIBRARIES.AnswerService));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.EntryHelperService = window.EC5_LIBRARIES.EntryHelperService || {};
/**
 * Entry Helper Service
 */
(function entryHelperService (module) {

    /**
     * Add default answers for all questions in entry
     */
    module.addDefaultAnswers = function (entry, inputs, addFakeAnswers) {

        let answerService = window.EC5_LIBRARIES.AnswerService;

        // Use fake answer service?
        if (addFakeAnswers) {
            answerService = window.EC5_LIBRARIES.FakeAnswerService;
        }

        // Loop round and pre populate the answers for each question
        for (let i = 0; i < inputs.length; i++) {

            const inputsExtra = window.EC5_LIBRARIES.ProjectModel.getExtraInputs();
            const inputDetails = inputsExtra[inputs[i]].data;

            // Add answer
            entry.answers[inputDetails.ref] = answerService.createDefaultAnswer(inputDetails);

            if (inputDetails.type === window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_GROUP_TYPE) {
                // Add group answers to main group
                const group = window.EC5_LIBRARIES.ProjectModel.getFormGroups(entry.formRef);
                for (let j = 0; j < group[inputDetails.ref].length; j++) {
                    const groupInputDetails = inputsExtra[group[inputDetails.ref][j]].data;
                    // Add answer
                    entry.answers[groupInputDetails.ref] = answerService.createDefaultAnswer(groupInputDetails);

                }
            }
        }

    };

    /**
     * Return current answers object
     * Populate answer for given input ref, if it doesn't exist
     *
     * @param entry
     * @param inputRef
     * @returns {*}
     */
    module.getAnswers = function (entry, inputRef) {

        // If we don't have an answer for this input ref yet, create one
        if (typeof entry.answers[inputRef] === 'undefined') {
            window.EC5_LIBRARIES.AnswerService.generateAnswer(entry, inputRef);
        }
        return entry.answers;
    };

    /**
     * Set the entry title
     *
     * @param form
     * @param inputs
     * @param entry
     * @param isBranch
     */
    module.setEntryTitle = function (form, inputs, entry, isBranch) {

        let titles = [];
        // Reset title
        entry.title = '';

        // Form
        if (!isBranch) {
            titles = window.EC5_LIBRARIES.AnswerService.getAnswersTitles(entry, form.inputs, form.group, inputs);
        } else {
            // Branch
            titles = window.EC5_LIBRARIES.AnswerService.getAnswersTitles(entry, form.branch[entry.ownerInputRef], form.group, inputs);
        }

        // If no title, use uuid
        if (titles.length === 0) {
            entry.title = entry.entryUuid;
        } else {
            entry.title = titles.join(' ');
        }

    };

    /**
     * Get the next input ref
     * Processing any jumps
     *
     * @param entry
     * @param answer
     * @param inputDetails
     * @param currentInputIndex
     * @param inputs
     * @returns {*}
     */

    module.processJumpsNext = function (entry, answer, inputDetails, currentInputIndex, inputs) {
        // Retrieve next input index/ref
        const nextInputIndex = currentInputIndex + 1;
        const nextInputRef = inputs[nextInputIndex] ? inputs[nextInputIndex] : null;

        return window.EC5_LIBRARIES.JumpService.processJumpsNext(entry, answer, inputDetails, nextInputIndex, nextInputRef);
    };

    /**
     * Get the previous input ref
     * Check for previous questions that were jumped
     *
     * @param entry
     * @param currentInputIndex
     * @param inputs
     * @returns {*}
     */
    module.processJumpsPrevious = function (entry, currentInputIndex, inputs) {
        // Retrieve previous input index
        const prevInputIndex = currentInputIndex - 1;

        return window.EC5_LIBRARIES.JumpService.processJumpsPrevious(entry, prevInputIndex, inputs);
    };

}(window.EC5_LIBRARIES.EntryHelperService));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.ErrorService = window.EC5_LIBRARIES.ErrorService || {};
/**
 * Error Service - for handling ec5 errors and bad responses
 */
(function errorService (module) {

    /**
     *
     * @param errors
     * @returns {*}
     * @private
     */
    const _getEc5Errors = function (errors) {

        // Check we were given an array of errors
        if (errors && errors.constructor === Array && errors.length > 0) {
            // Show all errors
            for (let i = 0; i < errors.length; i++) {
                if (errors.hasOwnProperty(i) && errors[i].hasOwnProperty('code')) {
                    // Return first error
                    return errors[0].code;
                }
            }
        }

    };

    /**
     *
     * @param status
     * @returns {*}
     * @private
     */
    const _getStatusError = function (status) {

        switch (status) {
            case 0:
                // Unknown error, warn user
                return 'ec5_103';
            case 404:
                // Server url wrong?
                return 'ec5_142';
            default:
                // Something else went wrong
                return 'ec5_116';
        }
    };

    /**
     * Takes an error response object and returns the error code
     *
     * @param response
     * @returns {*}
     */
    module.getWebErrorCode = function (response) {

        if (response) {
            // Check for an ec5 error
            if (response.hasOwnProperty('data') && response.data !== null) {
                if (response.data.hasOwnProperty('errors')) {
                    return _getEc5Errors(response.data.errors);
                }
            } else if (response.hasOwnProperty('status')) {
                // If no ec5  error found, check if we have a status error
                return _getStatusError(response.status);
            }
        }

        // Default error code
        return 'ec5_116';

    };

}(window.EC5_LIBRARIES.ErrorService));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.FakeAnswerService = window.EC5_LIBRARIES.FakeAnswerService || {};
/**
 * Fake Answer Service
 */
(function fakeAnswerService (module) {

    /**
     * Create default set of answers
     *
     * @param inputDetails
     * @returns {{}}
     */
    module.createDefaultAnswer = function (inputDetails) {

        const answer = { was_jumped: false };
        let random_idx;
        const longitude = -1.6129;// -1.890401;
        const latitude = 54.9778;//52.486243;

        const min = 0.0200;
        const max = 10.120;

        function randomDate (backTo) {
            // var date = new Date(+start + Math.random() * (end - start));
            // var hour = startHour + Math.random() * (endHour - startHour) | 0;
            // date.setHours(hour);
            // return date;
            const d = new Date(); // today!
            const x = Math.floor((Math.random() * backTo) + 1); // go back x days!
            d.setDate(d.getDate() - x);
            return d.toISOString();
        }

        function normish (mean, range) {
            let num_out;
            num_out = ((Math.random() + Math.random() + Math.random() + Math.random() - 2) / 2) * range + mean;
            return num_out;
        }

        function getRandomLocation (centerlon, centerlat) {

            const x = normish(0, 0.01);
            const y = normish(0, 0.01);

            return { longitude: ((x * 0.1) + centerlon), latitude: ((y * 0.1) + centerlat), accuracy: 0 };

        }

        function getRandomInRange (from, to, fixed) {
            return (Math.random() * (to - from) + from).toFixed(fixed) * 1;
            // .toFixed() returns string, so ' * 1' is a trick to convert to number
        }

        const lor = 'Far far away, behind the word mountains, far from the countries Vokalia and Consonantia, there live the blind texts. Separated they live in Bookmarksgrove right at the coast of the Semantics, a large language ocean. A small river named Duden flows by the.';


        // todo: create array here with lorem from different languages, picked randomly

        const lorLen = lor.length;
        const paLen = inputDetails.possible_answers.length;

        switch (inputDetails.type) {
            case 'text':
                if (inputDetails.regex) {
                    answer.answer = '';
                } else {
                    answer.answer = lor.substr(1, Math.floor(Math.random() * (lorLen / 2)));
                }

                break;

            case 'textarea':
                answer.answer = lor.substr(1, Math.floor(Math.random() * lorLen));
                break;

            case 'integer':
                if (inputDetails.min) {
                    answer.answer = inputDetails.min;
                } else if (inputDetails.max) {
                    answer.answer = inputDetails.max;
                } else {
                    answer.answer = Math.floor((Math.random() * 25000) + 1);
                }

                break;

            case 'decimal':
                if (inputDetails.min) {
                    answer.answer = inputDetails.min;
                } else if (inputDetails.max) {
                    answer.answer = inputDetails.max;
                } else {
                    answer.answer = (Math.random() * (max - min) + min).toFixed(4);
                }

                break;

            case 'radio':
                random_idx = Math.floor((Math.random() * paLen));
                answer.answer = inputDetails.possible_answers[random_idx].answer_ref;
                break;

            case 'dropdown':
                random_idx = Math.floor((Math.random() * paLen));
                answer.answer = inputDetails.possible_answers[random_idx].answer_ref;
                break;

            case 'checkbox':
                random_idx = Math.floor((Math.random() * paLen));
                answer.answer = [];
                answer.answer.push(inputDetails.possible_answers[random_idx].answer_ref);
                break;

            case 'barcode':
                answer.answer = 'xxxxx-xxxx-xxx'.replace(/[xy]/g, (c) => {
                    let r = Math.random() * 16 || 0,
                        v = c === 'x' ? r : (r && 0x3 || 0x8);
                    return v.toString(16);
                });
                break;

            case 'location':
                //Antonio locations
                //answer.answer = getRandomLocation(longitude, latitude);
                //Custom Locations (whole world range are -170 + 170 for lat, -80 +80 for long, considering a bit of padding)
                //please amend accordingly
                answer.answer = getRandomLocation(getRandomInRange(-160, 160, 5), getRandomInRange(-80, 80, 5));

                break;

            case 'date':
                answer.answer = randomDate(365);
                break;

            case 'time':
                answer.answer = randomDate(365);
                break;

            default:
                answer.answer = '';
        }


        return answer;
    };


}(window.EC5_LIBRARIES.FakeAnswerService));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
/**
 * Utilities JSON Formatter Service - for formatting to/from JSON
 */
window.EC5_LIBRARIES.JsonFormatter = {

    /**
     * Make the json entry object
     *
     * @param entry
     * @returns {{type: *, id: *, attributes: {form: {ref: *, type: string}}, relationships: {parent: {}, branch: {}}}}
     */
    makeJsonEntry (entry) {

        let branch = {};
        let parent = {};

        // If this entry has a parent
        if (entry.parent_entry_uuid) {
            parent = {
                data: {
                    parent_form_ref: entry.parent_form_ref,
                    parent_entry_uuid: entry.parent_entry_uuid
                }
            };
        }

        if (entry.owner_entry_uuid) {
            branch = {
                data: {
                    owner_input_ref: entry.owner_input_ref,
                    owner_entry_uuid: entry.owner_entry_uuid
                }
            };
        }

        const entryJson = {
            type: entry.entry_type,
            id: entry.entry_uuid,
            attributes: {
                form: {
                    ref: entry.form_ref,
                    type: 'hierarchy'
                }
            },
            relationships: {
                parent,
                branch
            }
        };

        try {
            entryJson[entry.entry_type] = {
                entry_uuid: entry.entry_uuid,
                created_at: entry.created_at,
                device_id: entry.device_id,
                platform: entry.platform,
                title: entry.title,
                answers: JSON.parse(entry.answers),
                project_version: entry.last_updated
            };
        } catch (e) {
            // Failed - just reset the answers
            entryJson[entry.entry_type] = {};
        }

        return entryJson;

    },

    /**
     * Make the json file entry object
     *
     * @param file
     * @returns {{type: string, id: *, entry_uuid: *, attributes: {form: {ref: *, type: string}}, relationships: {parent: {}, branch: {}}, file: {name: *, type: *, input_ref: *}, structure_last_updated: string}}
     */
    makeJsonFileEntry (file) {

        return {
            type: 'file_entry',
            id: file.entry_uuid,
            attributes: {
                form: {
                    ref: file.form_ref,
                    type: 'hierarchy'
                }
            },
            relationships: {
                parent: {},
                branch: {}
            },
            file_entry: {
                entry_uuid: file.entry_uuid,
                name: file.file_name,
                type: file.file_type,
                input_ref: file.input_ref,
                project_version: file.structure_last_updated,
                created_at: file.created_at || new Date().toISOString(),
                device_id: file.device_id || '',
                platform: file.platform || ''
            }
        };

    }
};


'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.JumpService = window.EC5_LIBRARIES.JumpService || {};
/**
 * Jump Service - for processing question jumps
 */
(function jumpService (module) {

    /**
     * Get the next input ref
     * Process the jumps
     *
     * @param entry
     * @param answer
     * @param inputDetails
     * @param nextInputIndex
     * @param nextInputRef
     * @returns {{next_input_ref: *, next_input_index: *}}
     */
    module.processJumpsNext = function (entry, answer, inputDetails, nextInputIndex, nextInputRef) {

        let newNextInputIndex = nextInputIndex;

        // Check if we have jumps here
        if (inputDetails.jumps.length > 0) {

            // Update the nextInputRef, if necessary
            nextInputRef = module.getNextInputRef(answer.answer, inputDetails, nextInputRef);

            // Retrieve the index for this updated nextInputRef
            newNextInputIndex = module.getInputIndexFromRef(entry, nextInputRef);

            // If there is a difference, we are going to jump questions
            if (nextInputIndex < newNextInputIndex) {
                module.jumpQuestions(entry, nextInputIndex, newNextInputIndex);
            }
        }

        return {
            next_input_ref: nextInputRef,
            next_input_index: newNextInputIndex
        };
    };

    /**
     * Jump questions between the two input indexes
     * Set any answer 'was_jumped' properties to true where necessary
     *
     * @param entry
     * @param firstInputIndex
     * @param secondInputIndex
     */
    module.jumpQuestions = function (entry, firstInputIndex, secondInputIndex) {

        let currentInput;
        let currentInputRef;
        let i;
        let group;
        let groupInput;

        // Loop through each input in between
        for (firstInputIndex; firstInputIndex < secondInputIndex; firstInputIndex++) {

            // Get this input ref
            currentInputRef = module.getInputRefFromIndex(entry, firstInputIndex);
            currentInput = window.EC5_LIBRARIES.ProjectModel.getInput(currentInputRef);

            // Set was_jumped = true for this input ref
            module.setJumped(entry, currentInputRef);

            // If this input is a group, loop each group input and set was_jumped = true
            if (currentInput.type === window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_GROUP_TYPE) {
                group = window.EC5_LIBRARIES.ProjectModel.getGroupInputs(entry.formRef, currentInputRef);
                for (i = 0; i < group.length; i++) {
                    groupInput = window.EC5_LIBRARIES.ProjectModel.getInput(group[i].ref);
                    // Set was_jumped = true for this group input ref
                    module.setJumped(entry, groupInput.ref);
                }
            }
        }
    };

    /**
     * Set was_jumped = true
     * @param entry
     * @param inputRef
     */
    module.setJumped = function (entry, inputRef) {

        // If we don't have an answer for this input ref yet, create one
        if (typeof entry.answers[inputRef] === 'undefined') {
            window.EC5_LIBRARIES.AnswerService.generateAnswer(entry, inputRef);
        }
        entry.answers[inputRef].was_jumped = true;
    };

    /**
     * Get the previous input ref
     * Check for previous questions that were jumped
     *
     * @param entry
     * @param prevInputIndex
     * @param inputs
     * @returns {{previous_input_ref: *, previous_input_index: *}}
     */
    module.processJumpsPrevious = function (entry, prevInputIndex, inputs) {

        // Retrieve previous input index/ref
        let prevInputRef = inputs[prevInputIndex];

        // While each previous answer was jumped,
        // decrement the index and try again with the associated input ref
        // until we find an input that wasn't jumped
        while (entry.answers[prevInputRef].was_jumped === true) {
            prevInputIndex -= 1;
            prevInputRef = inputs[prevInputIndex];
        }

        return {
            previous_input_ref: prevInputRef,
            previous_input_index: prevInputIndex
        };
    };

    /**
     * Get the next input ref, if questions are jumped
     *
     * @param answer
     * @param inputDetails
     * @param nextInputRef
     * @returns {*}
     */
    module.getNextInputRef = function (answer, inputDetails, nextInputRef) {

        let i;

        for (i = 0; i < inputDetails.jumps.length; i++) {

            const currentJump = inputDetails.jumps[i];

            if (module.shouldJump(currentJump, inputDetails, answer)) {
                // If we are jumping to the END of the form, set nextInputRef to null,
                // indicating the end of the form
                return (currentJump.to === window.EC5_LIBRARIES.PARAMETERS.JUMPS.END_OF_FORM ? null : currentJump.to);
            }
        }
        // If no jumping, return original nextInputRef
        return nextInputRef;
    };

    /**
     * Check if an answer meets the criteria to initialise a jump
     *
     * @param currentJump
     * @param inputDetails
     * @param answer
     * @returns {boolean}
     */
    module.shouldJump = function (currentJump, inputDetails, answer) {

        switch (inputDetails.type) {
            // Treat checkboxes differently to other input types,
            // as we can have more than one answer here
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_CHECKBOX_TYPE:
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_SEARCH_SINGLE_TYPE:
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_SEARCH_MULTIPLE_TYPE:

                var index;

                switch (currentJump.when) {

                    case window.EC5_LIBRARIES.PARAMETERS.JUMPS.IS:
                        // If the answer matches the jumped answer
                        for (index in answer) {
                            if (answer.hasOwnProperty(index)) {
                                if (answer[index]) {
                                    if (answer[index] === currentJump.answer_ref) {
                                        return true;
                                    }
                                }
                            }
                        }
                        break;
                    case window.EC5_LIBRARIES.PARAMETERS.JUMPS.IS_NOT:
                        // If the answer doesn't match the jumped answer
                        for (index in answer) {
                            if (answer.hasOwnProperty(index)) {
                                if (answer[index]) {
                                    if (answer[index] === currentJump.answer_ref) {
                                        return false;
                                    }
                                }
                            }
                        }
                        // No answers match jump answer
                        return true;
                    case window.EC5_LIBRARIES.PARAMETERS.JUMPS.NO_ANSWER_GIVEN:
                        // If no answer
                        for (index in answer) {
                            if (answer.hasOwnProperty(index)) {
                                if (answer[index]) {
                                    return false;
                                }
                            }
                        }
                        // No answers given
                        return true;
                    case window.EC5_LIBRARIES.PARAMETERS.JUMPS.ALL:
                        // Always jump
                        return true;
                }

                break;
            default:
                // Every other input types
                switch (currentJump.when) {
                    case window.EC5_LIBRARIES.PARAMETERS.JUMPS.IS:
                        // If the answer matches the jumped answer
                        if (answer === currentJump.answer_ref) {
                            return true;
                        }
                        break;
                    case window.EC5_LIBRARIES.PARAMETERS.JUMPS.IS_NOT:
                        // If the answer doesn't match the jumped answer
                        if (answer !== currentJump.answer_ref) {
                            return true;
                        }
                        break;
                    case window.EC5_LIBRARIES.PARAMETERS.JUMPS.NO_ANSWER_GIVEN:
                        // If no answer
                        if (answer === '') {
                            return true;
                        }
                        break;
                    case window.EC5_LIBRARIES.PARAMETERS.JUMPS.ALL:
                        // Always jump
                        return true;
                }
        }
        return false;
    };

    // HELPER FUNCTIONS

    /**
     *
     * @param entry
     * @param inputRef
     * @returns {*}
     */
    module.getInputIndexFromRef = function (entry, inputRef) {
        if (!entry.isBranch) {
            return window.EC5_LIBRARIES.ProjectModel.getInputIndexFromRef(entry.formRef, inputRef);
        }
        return window.EC5_LIBRARIES.ProjectModel.getBranchInputIndexFromRef(entry.formRef, entry.ownerInputRef, inputRef);

    };

    /**
     *
     * @param entry
     * @param inputIndex
     * @returns {*}
     */
    module.getInputRefFromIndex = function (entry, inputIndex) {
        if (!entry.isBranch) {
            return window.EC5_LIBRARIES.ProjectModel.getInputRefFromIndex(entry.formRef, inputIndex);
        }
        return window.EC5_LIBRARIES.ProjectModel.getBranchInputRefFromIndex(entry.formRef, entry.ownerInputRef, inputIndex);

    };

}(window.EC5_LIBRARIES.JumpService));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.UtilsService = window.EC5_LIBRARIES.UtilsService || {};
/**
 * Utilities Service - for general utilities
 */
(function utilsService (module) {

    /**
     * Helper method to create a uuid
     *
     * @returns {string}
     */
    module.uuid = function () {
        //new method to generated uuid, much better -> https://goo.gl/82GDUJ
        let d = new Date().getTime();
        if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
            //console.log(performance.now());
            d += performance.now(); //use high-precision timer if available
        }
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
            const r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
    };

    module.getTimeZone = function () {
        let offset = new Date().getTimezoneOffset(),
            o = Math.abs(offset);
        return 'GMT' + (offset < 0 ? '+' : '-') + ('00' + Math.floor(o / 60)).slice(-2) + ':' + ('00' + (o % 60)).slice(-2);
    };

    /**
     * Input type="date" wants the value to be set to YYYY-MM-DD
     *
     * @param input_date
     * @returns {string}
     */
    module.getInputFormattedDate = function (input_date) {

        const date = new Date(input_date);

        const day = ('0' + date.getUTCDate()).slice(-2);
        const month = ('0' + (date.getUTCMonth() + 1)).slice(-2);
        const year = date.getUTCFullYear();

        return year + '-' + month + '-' + day;
    };

    /**
     * Input type="time" wants the value to be set to HH:mm
     *
     * @param input_date
     * @returns {string}
     */
    //get time based on UTC
    module.getInputFormattedTimeUTC = function (input_date) {

        const date = new Date(input_date);
        const hours = ('0' + date.getUTCHours()).slice(-2);
        const minutes = ('0' + date.getUTCMinutes()).slice(-2);
        const seconds = ('0' + date.getUTCSeconds()).slice(-2);

        return hours + ':' + minutes + ':' + seconds;
    };
    //get time based on user locale
    module.getInputFormattedTimeLocale = function (input_date) {

        const date = new Date(input_date);
        const hours = ('0' + date.getHours()).slice(-2);
        const minutes = ('0' + date.getMinutes()).slice(-2);
        const seconds = ('0' + date.getSeconds()).slice(-2);

        return hours + ':' + minutes + ':' + seconds;
    };

    /**
     *
     * @param input_date
     * @param the_format
     * @returns {string}
     */
    module.getUserFormattedDate = function (input_date, the_format) {

        const date = new Date(input_date);
        const format = the_format;
        const day = ('0' + date.getDate()).slice(-2);
        const month = ('0' + (date.getMonth() + 1)).slice(-2);
        const year = date.getFullYear();
        let formatted_date = '';

        switch (format) {
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_1:
                //'dd/MM/YYYY',
                formatted_date = day + '/' + month + '/' + year;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_2:
                //'MM/dd/YYYY',
                formatted_date = month + '/' + day + '/' + year;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_3:
                formatted_date = year + '/' + month + '/' + day;
                //'YYYY/MM/dd',
                break;
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_4:
                //'MM/YYYY',
                formatted_date = year + '/' + day;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_5:
                //'dd/MM',
                formatted_date = day + '/' + month;
                break;
        }

        return formatted_date;
    };

    module.getUserFormattedDateFromISOString = function (input_date, the_format) {
        if (input_date === '') {
            return '';
        }

        const date = input_date.split('T');
        const dateParts = date[0].split('-');
        const format = the_format;
        const day = dateParts[2];
        const month = dateParts[1];
        const year = dateParts[0];
        let formattedDate = '';

        switch (format) {
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_1:
                //'dd/MM/YYYY',
                formattedDate = day + '/' + month + '/' + year;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_2:
                //'MM/dd/YYYY',
                formattedDate = month + '/' + day + '/' + year;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_3:
                formattedDate = year + '/' + month + '/' + day;
                //'YYYY/MM/dd',
                break;
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_4:
                //'MM/YYYY',
                formattedDate = year + '/' + day;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.DATE_FORMAT_5:
                //'dd/MM',
                formattedDate = day + '/' + month;
                break;
        }
        return formattedDate;
    };

    /**
     *
     * @param input_date
     * @param the_format
     * @returns {string}
     */
    module.getUserFormattedTime = function (input_date, the_format) {

        const date = new Date(input_date);
        const format = the_format;
        const hours24 = ('0' + date.getUTCHours()).slice(-2);
        const hours12 = ((hours24 + 11) % 12) + 1;
        const minutes = ('0' + date.getUTCMinutes()).slice(-2);
        const seconds = ('0' + date.getUTCSeconds()).slice(-2);
        let formatted_time = '';

        switch (format) {
            case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_1:
                //HH:mm:ss (24 hrs format)
                formatted_time = hours24 + ':' + minutes + ':' + seconds;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_2:
                //hh:mm:ss (12 hrs format)
                formatted_time = hours12 + ':' + minutes + ':' + seconds;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_3:
                //HH:mm (24hrs format)
                formatted_time = hours24 + ':' + minutes;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_4:
                //hh:mm (12 hrs format)
                formatted_time = hours12 + ':' + minutes;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.TIME_FORMAT_5:
                //mm:ss
                formatted_time = minutes + ':' + seconds;
                break;
        }
        return formatted_time;
    };

    /*
     Value for media is created like {input ref}_{YYYYMMDD}_{filename} where file name will be {timestamp}.{ext}
     */
    module.generateMediaFilename = function (uuid, type) {

        let ext;

        switch (type) {
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_PHOTO_TYPE:
                ext = window.EC5_LIBRARIES.PARAMETERS.PHOTO_EXT;
                break;
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_AUDIO_TYPE:
                if (window.device.platform === window.EC5_LIBRARIES.PARAMETERS.IOS) {
                    //ios will record only .wav format
                    ext = window.EC5_LIBRARIES.PARAMETERS.AUDIO_EXT_IOS;
                } else {
                    //android is ok with .mp4
                    ext = window.EC5_LIBRARIES.PARAMETERS.AUDIO_EXT;
                }
                break;
            case window.EC5_LIBRARIES.PARAMETERS.INPUT_TYPES.EC5_VIDEO_TYPE:
                ext = window.EC5_LIBRARIES.PARAMETERS.VIDEO_EXT;
                break;
        }

        return uuid + '_' + module.generateTimestamp() + ext;
    };

    /**
     * Generate a timestamp in ms
     *
     * @returns {number}
     */
    module.generateTimestamp = function () {
        return Math.floor(Date.now() / 1000);
    };

    /** Get ISO8601 representation in UTC, removing timezone
     *
     * @param date
     * @returns {string}
     */
    module.getIsoDateTime = function (date) {

        const self = this;

        //// If we weren't supplied a date, generate a new one
        if (!date) {
            date = new Date();
        }

        //IMPORTANT: store dates removing timezone, UTC for the wins!
        //this is for ordering, then the user will see the date converted to the local timezone anyway
        //add 'Z' to indicate Zulu time (UTC, timezone offest 0)

        return self.getISO8601String(self.convertDateToUTC(date)) + 'Z';
    };

    module.getISODateOnly = function (date) {

        let current_date = date.getDate(),
            current_month = date.getMonth() + 1,
            current_year = date.getFullYear();

        // Add 0 before date, month if they are less than 0
        current_date = current_date < 10 ? '0' + current_date : current_date;
        current_month = current_month < 10 ? '0' + current_month : current_month;

        // String such as 2016-07-16T00:00:00
        return current_year + '-' + current_month + '-' + current_date + 'T00:00:00.000';
    };


    module.getTimezoneOffset = function (date) {

        let timezone_offset_min = date.getTimezoneOffset(),
            offset_hrs = parseInt(Math.abs(timezone_offset_min / 60)),
            offset_min = Math.abs(timezone_offset_min % 60),
            timezone_standard;

        if (offset_hrs < 10) {
            offset_hrs = '0' + offset_hrs;
        }

        if (offset_min < 10) {
            offset_min = '0' + offset_min;
        }

        // Add an opposite sign to the offset
        // If offset is 0, it means timezone is UTC
        if (timezone_offset_min < 0) {
            timezone_standard = '+' + offset_hrs + ':' + offset_min;
        } else if (timezone_offset_min > 0) {
            timezone_standard = '-' + offset_hrs + ':' + offset_min;
        } else if (timezone_offset_min === 0) {
            timezone_standard = 'Z';
        }

        // Timezone difference in hours and minutes
        // String such as +5:30 or -6:00 or Z
        console.log(timezone_standard);

        return timezone_standard;
    };

    module.getISO8601String = function (dt) {

        let current_date = dt.getDate(),
            current_month = dt.getMonth() + 1,
            current_year = dt.getFullYear(),
            current_hrs = dt.getHours(),
            current_mins = dt.getMinutes(),
            current_secs = dt.getSeconds(),
            current_millisecs = dt.getMilliseconds(),
            current_datetime;

        // Add 0 before date, month, hrs, mins or secs if they are less than 0
        current_date = current_date < 10 ? '0' + current_date : current_date;
        current_month = current_month < 10 ? '0' + current_month : current_month;
        current_hrs = current_hrs < 10 ? '0' + current_hrs : current_hrs;
        current_mins = current_mins < 10 ? '0' + current_mins : current_mins;
        current_secs = current_secs < 10 ? '0' + current_secs : current_secs;

        //add leading 0 or 00 to milliseconds
        if (current_millisecs < 100) {
            if (current_millisecs < 10) {
                current_millisecs = '00' + current_millisecs;
            } else {
                current_millisecs = '0' + current_millisecs;
            }
        }

        // Current datetime
        // String such as 2016-07-16T19:20:30
        current_datetime = current_year + '-' + current_month + '-' + current_date + 'T' + current_hrs + ':' + current_mins + ':' + current_secs + '.' + current_millisecs;

        return current_datetime;
    };

    //convert a local date to UTC date, so real date without the timezone offset added in
    module.convertDateToUTC = function (date, removeMilliseconds) {

        if (removeMilliseconds) {
            return new Date(
                date.getUTCFullYear(),
                date.getUTCMonth(),
                date.getUTCDate(),
                date.getUTCHours(),
                date.getUTCMinutes(),
                date.getUTCSeconds()
            );
        }

        return new Date(
            date.getUTCFullYear(),
            date.getUTCMonth(),
            date.getUTCDate(),
            date.getUTCHours(),
            date.getUTCMinutes(),
            date.getUTCSeconds(),
            date.getUTCMilliseconds()
        );

    };

    //add/remove the timezone offset from the local time to level out timezone differences and have the Date in GMT always
    module.getDateWithCompensatedTimezone = function (date) {

        //local date
        const compDate = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
        );

        console.log('timezone offset ->', compDate.getTimezoneOffset() * 60 * 1000);
        //remove timezone
        compDate.setTime(compDate.getTime() + compDate.getTimezoneOffset() * 60 * 1000);
        return compDate;
    };

    //strip milliseconds from Date() for display on time picker
    module.stripMillisecondsfromDate = function (date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());
    };

    /**
     * Map media object to array filtering out all the inputs without any answer.
     * The media object is first indexed by entryUuid, then inputRef. ie media[entryUuid][inputRef] = {}
     *
     * @param entryMediaObj
     * @returns {Array}
     */
    module.mapMediaObjectToArray = function (entryMediaObj) {
        console.log(entryMediaObj);
        const array = [];

        Object.keys(entryMediaObj)
            .map((entryUuid) => {

                const inputMediaObj = entryMediaObj[entryUuid];

                /**
                 *  Filter empty answers
                 *  A file is only saved when 'cached' has a value
                 */
                Object.keys(inputMediaObj)
                    .map((inputRef) => {
                        // todo check why cached undefined
                        if (inputMediaObj[inputRef].cached !== '') {
                            array.push({
                                entry_uuid: entryUuid,
                                input_ref: inputRef,
                                cached: inputMediaObj[inputRef].cached,
                                stored: inputMediaObj[inputRef].stored,
                                type: inputMediaObj[inputRef].type
                            });
                        }
                    });

            });

        return array;
    };

    /**
     * Serialize an object to a url string
     *
     * @param obj
     * @returns {string}
     */
    module.serializeToUrl = function (obj) {
        const str = [];
        for (const p in obj) {
            if (obj.hasOwnProperty(p)) {
                str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
            }
        }
        return str.join('&');
    };

    /**
     *
     * @param str
     * @returns {*}
     */
    module.stripTrailingSlash = function (str) {
        if (str.substr(-1) === '/') {
            return str.substr(0, str.length - 1)
                .toLowerCase();
        }
        return str.toLowerCase();
    };

    /**
     *
     * @param obj
     * @returns {string}
     */
    module.serializeObj = function (obj) {
        const result = [];

        Object.keys(obj)
            .forEach((key, index) => {
                result.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));
            });

        return result.join('&');
    };

    module.htmlDecode = function (input) {

        let html;
        let div;
        let scripts;
        let i;

        div = document.createElement('div');
        div.innerHTML = input;
        // Get parsed html
        html = div.childNodes.length === 0 ? '' : div.childNodes[0].nodeValue;

        // Now remove all script tags
        div = document.createElement('div');
        div.innerHTML = html;
        scripts = div.getElementsByTagName('script');
        // Loop them and remove
        i = scripts.length;
        while (i--) {
            scripts[i].parentNode.removeChild(scripts[i]);
        }

        // Return the inner html
        return div.innerHTML;
    };


}(window.EC5_LIBRARIES.UtilsService));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.BranchEntryModel = window.EC5_LIBRARIES.BranchEntryModel || {};
/**
 * Branch Entry Model
 */
(function branchEntryModel (module) {

    /**
     * Initialise the branch entry model
     *
     * @param entry
     */
    module.initialise = function (entry) {

        module.entryUuid = entry.entry_uuid;
        module.ownerEntryUuid = entry.owner_entry_uuid;
        module.ownerInputRef = entry.owner_input_ref;
        module.isRemote = entry.is_remote;
        module.synced = entry.synced;
        module.canEdit = entry.can_edit;
        module.createdAt = entry.created_at;
        module.title = entry.title ? entry.title : '';
        module.formRef = entry.form_ref;
        module.parentFormRef = entry.parent_form_ref;
        module.projectRef = entry.project_ref;
        module.media = (entry.media ? entry.media : {});
        module.uniqueAnswers = {};
        module.syncedError = entry.synced_error;
        module.isBranch = true;

        // Attempt to parse the json
        try {
            module.answers = (typeof entry.answers === 'object' ? entry.answers : JSON.parse(entry.answers));
        } catch (e) {
            // Failed
            module.answers = {};
        }
    };

}(window.EC5_LIBRARIES.BranchEntryModel));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.EntryModel = window.EC5_LIBRARIES.EntryModel || {};
/**
 * Entry Model
 */
(function entryModel (module) {

    /**
     * Initialise the entry model
     *
     * @param entry
     */
    module.initialise = function (entry) {

        module.entryUuid = entry.entry_uuid;
        module.parentEntryUuid = entry.parent_entry_uuid;
        module.isRemote = entry.is_remote;
        module.synced = entry.synced;
        module.canEdit = entry.can_edit;
        module.createdAt = entry.created_at;
        module.title = entry.title ? entry.title : '';
        module.formRef = entry.form_ref;
        module.parentFormRef = entry.parent_form_ref;
        module.projectRef = entry.project_ref;
        module.branchEntries = (entry.branchEntries ? entry.branchEntries : {});
        module.media = (entry.media ? entry.media : {});
        module.uniqueAnswers = {};
        module.syncedError = entry.synced_error;
        module.isBranch = false;
        module.verifyAnswers = {};

        // Attempt to parse the json
        try {
            module.answers = (typeof entry.answers === 'object' ? entry.answers : JSON.parse(entry.answers));
        } catch (e) {
            // Failed
            module.answers = {};
        }
    };

}(window.EC5_LIBRARIES.EntryModel));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.FormModel = window.EC5_LIBRARIES.FormModel || {};
/**
 * Form Model
 */
(function formModel (module) {

    module.formStructure = {};
    module.inputs = {};
    //todo is this needed?
    module.numInputsThisForm = 0;
    module.formRef = '';

    /**
     *
     * @param form
     */
    module.initialise = function (form) {
        module.formStructure = form;
        module.formRef = module.formStructure.details.ref;
    };

    /**
     * Remove the form model by resetting the attributes
     */
    module.remove = function () {
        module.formStructure = {};
        module.formRef = '';
        module.inputs = {};
        module.formRef = '';
        module.numInputsThisForm = 0;
    };

    /**
     *
     * @param inputs
     */
    module.addInputs = function (inputs) {
        module.inputs = inputs;
        //todo is this needed?
        module.numInputsThisForm = module.inputs.length;
    };

    /**
     * @returns {*}
     */
    module.getFormRef = function () {
        return module.formRef;
    };

    /**
     *
     * @returns {*}
     */
    module.getInputs = function () {
        return module.inputs;
    };

    /**
     *
     * @returns {*}
     */
    module.getName = function () {
        return module.formStructure.details.name;
    };

}(window.EC5_LIBRARIES.FormModel));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.ProjectModel = window.EC5_LIBRARIES.ProjectModel || {};
/**
 * Project Model
 */
(function projectModel (module) {

    module.project_extra = {};
    /**
     * Data from the local database
     * @type {{}}
     */
    module.data = {};

    /**
     * Initialise the model with data
     *
     * @param data
     */
    module.initialise = function (data) {

        module.data = data;

        // Attempt to load in the extra structure
        try {
            module.project_extra = JSON.parse(data.json_extra);
        } catch (e) {
            // Failed
        }

    };

    /**
     * Load in the project extra structure only
     *
     * @param projectExtra
     */
    module.loadExtraStructure = function (projectExtra) {
        module.project_extra = projectExtra;
    };

    /**
     *
     * @returns {boolean}
     */
    module.hasInitialised = function () {
        return (!!module.project_extra.project);
    };

    /**
     *
     * @returns {*}
     */
    module.getProjectExtra = function () {
        return module.project_extra;
    };

    /**
     * Remove this project model by resetting the attributes
     */
    module.remove = function () {
        module.project_extra = {};
        module.data = {};
    };

    /**
     *
     * @returns {*}
     */
    module.getProjectName = function () {
        return module.project_extra.project.details.name;
    };

    /**
     *
     * @returns {*}
     */
    module.getSlug = function () {
        return module.project_extra.project.details.slug;
    };

    /**
     *
     * @returns {string}
     */
    module.getProjectRef = function () {
        return (module.project_extra.project ? module.project_extra.project.details.ref : '');
    };

    /**
     *
     * @param formRef
     * @returns {{}}
     */
    module.getInputs = function (formRef) {
        return (module.project_extra.forms[formRef].inputs) ? module.project_extra.forms[formRef].inputs : {};
    };

    /**
     *
     * @returns {{}}
     */
    module.getInputsExtra = function () {
        return (module.project_extra.inputs) ? module.project_extra.inputs : {};
    };

    /**
     *
     * @returns {{}}
     */
    module.getExtraStructure = function () {
        return (module.project_extra) ? module.project_extra : {};
    };

    // FORMS
    /**
     *
     * @returns {*}
     */
    module.getExtraForms = function () {
        return (module.project_extra.forms) ? module.project_extra.forms : {};
    };

    /**
     *
     * @param formRef
     * @returns {{}}
     */
    module.getExtraForm = function (formRef) {
        return (module.project_extra.forms[formRef]) ? module.project_extra.forms[formRef] : {};
    };

    /**
     *
     * @returns {string}
     */
    module.getFirstFormRef = function () {
        return (module.project_extra.project.forms[0]) ? module.project_extra.project.forms[0] : '';
    };

    /**
     *
     * @returns {string}
     */
    module.getLastFormRef = function () {
        return (module.project_extra.project.forms[module.project_extra.project.forms.length - 1]) ? module.project_extra.project.forms[module.project_extra.project.forms.length - 1] : '';
    };

    /**
     *
     * @param formRef
     * @returns {string}
     */
    module.getNextFormRef = function (formRef) {

        // Loop round forms to get position of current form
        for (let i = 0; i < module.project_extra.project.forms.length; i++) {
            // Return next form in the array
            if (formRef === module.project_extra.project.forms[i]) {
                return (module.project_extra.project.forms[i + 1]) ? module.project_extra.project.forms[i + 1] : '';
            }
        }

    };

    /**
     *
     * @param formRef
     * @returns {string}
     */
    module.getParentFormRef = function (formRef) {

        // Loop round forms to get position of current form
        for (let i = 0; i < module.project_extra.project.forms.length; i++) {
            // return next form in the array
            if (formRef === module.project_extra.project.forms[i]) {
                return (module.project_extra.project.forms[i - 1]) ? module.project_extra.project.forms[i - 1] : '';
            }
        }

    };

    /**
     *
     * @param formRef
     * @returns {number}
     */
    module.getFormIndex = function (formRef) {

        // loop round forms to get position of current form
        for (let i = 0; i < module.project_extra.project.forms.length; i++) {
            // return next form in the array
            if (formRef === module.project_extra.project.forms[i]) {
                return i;
            }
        }

        return 0;

    };

    /**
     *
     * @returns {*}
     */
    module.getFirstForm = function () {
        return module.project_extra.forms[module.getFirstFormRef()];
    };

    /**
     *
     * @returns {*}
     */
    module.getFirstFormName = function () {
        return module.project_extra.forms[module.getFirstFormRef()].details.name;
    };

    /*

     */
    module.getFormName = function (formRef) {
        return module.project_extra.forms[formRef].details.name;
    };

    /**
     *
     * @param ref
     * @param data
     */
    module.addFormToExtra = function (ref, data) {

        const details = 'branch_entry';
        module.project_extra.forms[ref] = { details, inputs: [], cntinputs: 0 };
    };

    /**
     *
     * @returns {{}}
     */
    module.getExtraInputs = function () {
        return module.project_extra.inputs ? module.project_extra.inputs : {};
    };

    /**
     *
     * @param formRef
     * @returns {{}}
     */
    module.getFormInputs = function (formRef) {
        return (module.project_extra.forms[formRef].inputs) ? module.project_extra.forms[formRef].inputs : {};
    };

    /**
     *
     * @param inputRef
     * @returns {{}}
     */
    module.getInput = function (inputRef) {
        return module.project_extra.inputs[inputRef] ? module.project_extra.inputs[inputRef].data : {};
    };

    /**
     *
     * @param inputRef
     * @returns {boolean}
     */
    module.inputExists = function (inputRef) {
        return !!module.project_extra.inputs[inputRef];
    };

    /**
     *
     * @param formRef
     * @param inputRef
     * @returns {*}
     */
    module.getInputIndexFromRef = function (formRef, inputRef) {

        for (let i = 0; i < module.project_extra.forms[formRef].inputs.length; i++) {

            if (module.project_extra.forms[formRef].inputs[i] === inputRef) {
                return i;
            }
        }
        // Otherwise return the end of the form index
        return module.project_extra.forms[formRef].inputs.length;

    };

    /**
     *
     * @param formRef
     * @param ownerInputRef
     * @param inputRef
     * @returns {*}
     */
    module.getBranchInputIndexFromRef = function (formRef, ownerInputRef, inputRef) {

        for (let i = 0; i < module.project_extra.forms[formRef].branch[ownerInputRef].length; i++) {

            if (module.project_extra.forms[formRef].branch[ownerInputRef][i] === inputRef) {
                return i;
            }
        }
        // Otherwise return the end of the form index
        return module.project_extra.forms[formRef].branch[ownerInputRef].length;
    };

    /**
     *
     * @param formRef
     * @param inputIndex
     * @returns {null}
     */
    module.getInputRefFromIndex = function (formRef, inputIndex) {
        return (module.project_extra.forms[formRef].inputs[inputIndex] ? module.project_extra.forms[formRef].inputs[inputIndex] : null);
    };

    /**
     *
     * @param formRef
     * @param ownerInputRef
     * @param inputIndex
     * @returns {null}
     */
    module.getBranchInputRefFromIndex = function (formRef, ownerInputRef, inputIndex) {
        return (module.project_extra.forms[formRef].branch[ownerInputRef][inputIndex] ? module.project_extra.forms[formRef].branch[ownerInputRef][inputIndex] : null);
    };

    // BRANCHES
    /**
     *
     * @param formRef
     * @returns {{}}
     */
    module.getFormBranches = function (formRef) {
        return (module.project_extra.forms[formRef].branch) ? module.project_extra.forms[formRef].branch : {};
    };

    /**
     *
     * @param formRef
     * @param inputRef
     * @returns {{}}
     */
    module.getBranches = function (formRef, inputRef) {
        return (module.project_extra.forms[formRef].branch[inputRef]) ? module.project_extra.forms[formRef].branch[inputRef] : {};
    };

    /**
     *
     * @param formRef
     */
    module.formHasBranches = function (formRef) {
        // TODO
    };

    // GROUPS
    /**
     *
     * @param formRef
     * @returns {{}}
     */
    module.getFormGroups = function (formRef) {
        return (module.project_extra.forms[formRef].group) ? module.project_extra.forms[formRef].group : {};
    };

    /**
     *
     * @param formRef
     * @param inputRef
     * @returns {Array}
     */
    module.getGroupInputs = function (formRef, inputRef) {

        const out = [];
        let i;
        let group;

        if (module.project_extra.forms[formRef].group[inputRef]) {
            group = module.project_extra.forms[formRef].group[inputRef];
            // loop group input refs and retrieve inputs
            for (i = 0; i < group.length; i++) {
                out[i] = module.getInput(group[i]);
            }
        }

        return out;
    };

    /**
     *
     * @returns {{}}
     */
    module.getListForms = function () {
        return (module.project_extra.listForms) ? module.project_extra.listForms : [];
    };

    /**
     *
     * @param form_ref
     * @returns {*}
     */
    module.hasLocation = function (form_ref) {
        return module.project_extra.forms[form_ref].details.has_location;
    };

    /**
     *
     * @param ref
     * @returns {*}
     */
    module.getEntriesLimit = function (ref) {
        return module.project_extra.project.entries_limits && module.project_extra.project.entries_limits[ref] ? module.project_extra.project.entries_limits[ref] : null;
    };


}(window.EC5_LIBRARIES.ProjectModel));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.AnswerValidateHelper = window.EC5_LIBRARIES.AnswerValidateHelper || {};
/**
 * Text Validate
 */
(function answerValidateHelper (module) {

    module.validators = {};

    /**
     * Set the validators
     *
     */
    module.setValidators = function (validators) {
        module.validators = validators;
    };

    /**
     * errors
     * @type {{}}
     */
    module.errors = {};

    /**
     *
     * @returns {Array}
     */
    module.getErrors = function () {
        return module.errors;
    };

    /**
     *
     * @returns {boolean}
     */
    module.hasErrors = function () {
        return Object.keys(module.errors).length > 0;
    };

    /**
     *
     */
    module.resetErrors = function () {
        module.errors = {};
    };

    /* HELPER FUNCTIONS */

    /**
     * Make input type specific answer checks
     *
     * @param params
     */
    module.answerChecks = function (params) {

        let result = true;

        // Retrieve validator based on input type
        const validator = module.validators[params.input_details.type];

        // If we have a validator for this input type, run checks
        if (validator) {

            // Reset validator errors
            validator.errors = {};
            // Check for new errors
            result = validator.check(params);
            if (!result) {
                module.errors = validator.errors;
            }
        }

        return result;

    };

    /**
     * Check whether answer is required
     *
     * @param inputDetails
     * @param answer
     * @returns {boolean}
     */
    module.checkRequired = function (inputDetails, answer) {

        if (inputDetails.is_required === true) {
            // Check against all empty answer types
            if (answer === '' || answer === null || typeof answer === 'undefined' || (Array.isArray(answer) && answer.length === 0)) {
                module.errors[inputDetails.ref] = ['ec5_21'];
                return false;
            }
        }
        return true;
    };

    /**
     * Check the regular expression
     *
     * @param inputDetails
     * @param answer
     * @returns {boolean}
     */
    module.checkRegex = function (inputDetails, answer) {

        // Check regex is met
        if (inputDetails.regex !== null && inputDetails.regex !== '') {

            const re = new RegExp(inputDetails.regex);
            if (re.test(answer) === false) {
                module.errors[inputDetails.ref] = ['ec5_23'];
                return false;
            }
        }
        return true;

    };

    /**
     * Check confirmed field
     *
     * @param inputDetails
     * @param answer
     * @param confirmAnswer
     * @returns {boolean}
     */
    module.checkConfirmed = function (inputDetails, answer, confirmAnswer) {

        if (inputDetails.verify === true) {
            if (answer !== confirmAnswer) {
                module.errors[inputDetails.ref] = ['ec5_124'];
                return false;
            }
        }

        return true;

    };

}(window.EC5_LIBRARIES.AnswerValidateHelper));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.DateValidate = window.EC5_LIBRARIES.DateValidate || {};
/**
 * Date Validate
 */
(function dateValidate (module) {

    /**
     * errors
     * @type {{}}
     */
    module.errors = {};

    /**
     *
     * @param params
     */
    module.check = function (params) {

        const inputDetails = params.input_details;
        const answer = params.answer.answer;

        // Check the answer isn't too long
        if (window.EC5_LIBRARIES.InputValidateHelper.answerTooLong(answer, inputDetails.type)) {
            module.errors[inputDetails.ref] = ['ec5_214'];
            return false;
        }

        return true;

    };

}(window.EC5_LIBRARIES.DateValidate));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.DecimalValidate = window.EC5_LIBRARIES.DecimalValidate || {};
/**
 * Decimal Validate
 */
(function decimalValidate (module) {

    /**
     * errors
     * @type {{}}
     */
    module.errors = {};

    /**
     * Check a decimal answer is valid
     *
     * @param params
     */
    module.check = function (params) {

        const inputDetails = params.input_details;
        const answer = params.answer.answer;

        // Skip empty strings and null
        // (ionic gives null when you try to enter letter by hacking)
        if (answer !== '' && answer !== null) {
            // Check is valid decimal
            if (!module.isDecimal(answer)) {
                module.errors[inputDetails.ref] = ['ec5_29'];
                return false;
            }

            // Check answer against the min and max
            if (module.outOfBounds(answer, inputDetails)) {
                module.errors[inputDetails.ref] = ['ec5_28'];
                return false;
            }
        }

        // Check the answer isn't too long
        if (window.EC5_LIBRARIES.InputValidateHelper.answerTooLong(answer, inputDetails.type)) {
            module.errors[inputDetails.ref] = ['ec5_214'];
            return false;
        }

        return true;
    };

    /**
     *
     * @param answer
     * @returns {boolean}
     */
    module.isDecimal = function (answer) {

        // optional -
        // at least one number [0-9]
        // optional . and 0 or more [0-9] afterwards
        return /^[\-]?[0-9]+\.?[0-9]*$/.test(answer);
    };

    /**
     * Check if the min and max values are not met
     * (if available)
     *
     * @param answer
     * @param inputDetails
     * @returns {boolean}
     */
    module.outOfBounds = function (answer, inputDetails) {

        if (!isNaN(answer)) {

            // Check min not empty
            if (inputDetails.min !== '') {
                // Check answer is not less than the min
                if (answer < inputDetails.min) {
                    return true;
                }
            }

            // Check max not empty
            if (inputDetails.max !== '') {
                // Check answer is not greater than the max
                if (answer > inputDetails.max) {
                    return true;
                }
            }
        }

        return false;

    };

}(window.EC5_LIBRARIES.DecimalValidate));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.DropdownValidate = window.EC5_LIBRARIES.DropdownValidate || {};
/**
 * Dropdown Validate
 */
(function dropdownValidate (module) {

    /**
     * errors
     * @type {{}}
     */
    module.errors = {};

    /**
     * Check possible answers for single selection inputs
     *
     * @param params
     */
    module.check = function (params) {

        const inputDetails = params.input_details;
        const answer = params.answer.answer;

        // Skip empty strings and null
        // (ionic gives null when you try to hack it)
        if (answer !== '' && answer !== null) {
            if (window.EC5_LIBRARIES.InputValidateHelper.possibleAnswerNotMatched(answer, inputDetails)) {
                module.errors[inputDetails.ref] = ['ec5_25'];
                return false;
            }
        }
        // Check the answer isn't too long
        if (window.EC5_LIBRARIES.InputValidateHelper.answerTooLong(answer, inputDetails.type)) {
            module.errors[inputDetails.ref] = ['ec5_214'];
            return false;
        }

        return true;
    };


}(window.EC5_LIBRARIES.DropdownValidate));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.InputValidateHelper = window.EC5_LIBRARIES.InputValidateHelper || {};
/**
 * Input Validate Helper
 */
(function inputValidateHelper (module) {

    /**
     * Check the answer length isn't too long, according to rules
     * set in the app config file
     *
     * @param answer
     * @param type
     * @returns {boolean}
     */
    module.answerTooLong = function (answer, type) {

        const typeString = 'EC5_' + type.toUpperCase() + '_TYPE';

        if (answer !== null &&
            typeof answer !== 'undefined' &&
            typeof window.EC5_LIBRARIES.PARAMETERS.INPUT_ANSWER_MAX_LENGTHS[typeString] !== 'undefined') {

            return (answer.toString().length > window.EC5_LIBRARIES.PARAMETERS.INPUT_ANSWER_MAX_LENGTHS[typeString]);
        }

        return false;

    };

    /**
     * Check that the answer matches one of the possible answers
     *
     * @param answer
     * @param inputDetails
     * @returns {boolean}
     */
    module.possibleAnswerNotMatched = function (answer, inputDetails) {

        // Default noMatch = true
        let noMatch = true;
        let possibleAnswer;

        if (inputDetails.possible_answers.length > 0) {

            // Loop over each possible answer
            for (possibleAnswer in inputDetails.possible_answers) {
                if (inputDetails.possible_answers.hasOwnProperty(possibleAnswer)) {
                    // If we have a match, set match = true
                    if (inputDetails.possible_answers[possibleAnswer].answer_ref === answer) {
                        noMatch = false;
                    }
                }
            }
        }

        return noMatch;
    };


}(window.EC5_LIBRARIES.InputValidateHelper));


'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.IntegerValidate = window.EC5_LIBRARIES.IntegerValidate || {};
/**
 * Integer Validate
 */
(function integerValidate (module) {

    /**
     * errors
     * @type {{}}
     */
    module.errors = {};

    /**
     * Check an integer answer is valid
     *
     * @param params
     */
    module.check = function (params) {

        const inputDetails = params.input_details;
        const answer = params.answer.answer;

        // Skip empty strings and null
        // (ionic gives null when you try to enter letter by hacking)
        if (answer !== '' && answer !== null) {
            // Check is valid integer
            if (!module.isInteger(answer)) {
                module.errors[inputDetails.ref] = ['ec5_29'];
                return false;
            }

            // Check answer against the min and max
            if (module.outOfBounds(answer, inputDetails)) {
                module.errors[inputDetails.ref] = ['ec5_28'];
                return false;
            }
        }

        // Check the answer isn't too long
        if (window.EC5_LIBRARIES.InputValidateHelper.answerTooLong(answer, inputDetails.type)) {
            module.errors[inputDetails.ref] = ['ec5_214'];
            return false;
        }

        return true;
    };

    /**
     *
     * @param answer
     * @returns {boolean}
     */
    module.isInteger = function (answer) {

        // optional -
        // at least one number 0-9
        return /^[\-]?[0-9]+$/.test(answer);
    };

    /**
     * Check if the min and max values are not met
     * (if available)
     *
     * @param answer
     * @param inputDetails
     * @returns {boolean}
     */
    module.outOfBounds = function (answer, inputDetails) {

        if (!isNaN(answer)) {

            // Check min not empty
            if (inputDetails.min !== '') {
                // Check answer is not less than the min
                if (answer < inputDetails.min) {
                    return true;
                }
            }

            // Check max not empty
            if (inputDetails.max !== '') {
                // Check answer is not greater than the max
                if (answer > inputDetails.max) {
                    return true;
                }
            }

        }

        return false;
    };


}(window.EC5_LIBRARIES.IntegerValidate));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.RadioValidate = window.EC5_LIBRARIES.RadioValidate || {};
/**
 * Radio Validate
 */
(function radioValidate (module) {

    /**
     * errors
     * @type {{}}
     */
    module.errors = {};

    /**
     * Check possible answers for single selection inputs
     *
     * @param params
     */
    module.check = function (params) {

        const inputDetails = params.input_details;
        const answer = params.answer.answer;

        // Skip empty strings and null
        // (ionic gives null when you hack)
        if (answer !== '' && answer !== null) {
            if (window.EC5_LIBRARIES.InputValidateHelper.possibleAnswerNotMatched(answer, inputDetails)) {
                module.errors[inputDetails.ref] = ['ec5_25'];
                return false;
            }
        }

        // Check the answer isn't too long
        if (window.EC5_LIBRARIES.InputValidateHelper.answerTooLong(answer, inputDetails.type)) {
            module.errors[inputDetails.ref] = ['ec5_214'];
            return false;
        }

        return true;
    };


}(window.EC5_LIBRARIES.RadioValidate));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.TextValidate = window.EC5_LIBRARIES.TextValidate || {};
/**
 * Text Validate
 */
(function textValidate (module) {

    /**
     * errors
     * @type {{}}
     */
    module.errors = {};

    /**
     *
     * @param params
     */
    module.check = function (params) {

        const inputDetails = params.input_details;
        const answer = params.answer.answer;

        // Check the answer isn't too long
        if (window.EC5_LIBRARIES.InputValidateHelper.answerTooLong(answer, inputDetails.type)) {
            module.errors[inputDetails.ref] = ['ec5_214'];
            return false;
        }

        return true;

    };

}(window.EC5_LIBRARIES.TextValidate));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.TextareaValidate = window.EC5_LIBRARIES.TextareaValidate || {};
/**
 * Textarea Validate
 */
(function textAreaValidate (module) {

    /**
     * errors
     * @type {{}}
     */
    module.errors = {};

    /**
     *
     * @param params
     */
    module.check = function (params) {

        const inputDetails = params.input_details;
        const answer = params.answer.answer;

        // Check the answer isn't too long
        if (window.EC5_LIBRARIES.InputValidateHelper.answerTooLong(answer, inputDetails.type)) {
            module.errors[inputDetails.ref] = ['ec5_214'];
            return false;
        }

        return true;

    };

}(window.EC5_LIBRARIES.TextareaValidate));

'use strict';
window.EC5_LIBRARIES = window.EC5_LIBRARIES || {};
window.EC5_LIBRARIES.TimeValidate = window.EC5_LIBRARIES.TimeValidate || {};
/**
 * Time Validate
 */
(function timeValidate (module) {

    /**
     * errors
     * @type {{}}
     */
    module.errors = {};

    /**
     *
     * @param params
     */
    module.check = function (params) {

        const inputDetails = params.input_details;
        const answer = params.answer.answer;

        // Check the answer isn't too long
        if (window.EC5_LIBRARIES.InputValidateHelper.answerTooLong(answer, inputDetails.type)) {
            module.errors[inputDetails.ref] = ['ec5_214'];
            return false;
        }

        return true;


    };

}(window.EC5_LIBRARIES.TimeValidate));

//# sourceMappingURL=libraries.min.js.map
